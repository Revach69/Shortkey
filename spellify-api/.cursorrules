# Spellify API - Cursor AI Rules (TypeScript + Firebase)

## ğŸ“š Read These Documents First

1. **`README.md`** - Setup, deployment, architecture
2. **`../docs/ARCHITECTURE.md`** - Full system architecture
3. **Firebase Functions docs** - https://firebase.google.com/docs/functions

---

## ğŸ¯ Core Rules (Must Follow)

### File Size
- âœ… Keep files **< 100 lines** (preferred)
- âœ… Max **150 lines** absolute limit
- âœ… If larger, **split into smaller modules**

### TypeScript
- âœ… **Strict mode enabled** (`tsconfig.json`)
- âœ… Use **explicit types** (no `any` unless necessary)
- âœ… Use **interfaces** for data structures
- âœ… Use **enums** for constants

### Code Structure
- âœ… One function per file (Cloud Functions)
- âœ… Services in `services/` directory
- âœ… Types in `types.ts`
- âœ… Config in `config.ts`

### Error Handling
- âœ… Use **HttpsError** for Cloud Functions
- âœ… Proper error codes (`invalid-argument`, `permission-denied`, etc.)
- âœ… User-friendly error messages
- âœ… Log errors for debugging

### Security
- âœ… **Validate all inputs** (use `validation.ts`)
- âœ… **Verify signatures** for sensitive operations
- âœ… Use **Firestore transactions** for atomic operations
- âœ… Follow **principle of least privilege**

### Comments & Documentation
- âœ… Comments explain **WHY**, not **WHAT**
- âŒ **No trivial comments** that repeat the code
- âœ… Document complex business logic
- âœ… Add JSDoc for exported functions

---

## ğŸ“– Examples in Codebase

### Perfect Service Examples:
- `services/device.ts` - Clean CRUD operations
- `services/quota.ts` - Atomic transactions
- `services/openai.ts` - External API integration

### Perfect Structure:
```
functions/src/
â”œâ”€â”€ index.ts              # Cloud Function handlers (orchestration)
â”œâ”€â”€ types.ts              # Shared TypeScript interfaces
â”œâ”€â”€ config.ts             # Configuration constants
â”œâ”€â”€ validation.ts         # Input validation
â”œâ”€â”€ crypto.ts             # Signature verification
â””â”€â”€ services/             # Business logic modules
    â”œâ”€â”€ device.ts
    â”œâ”€â”€ quota.ts
    â”œâ”€â”€ rateLimit.ts
    â”œâ”€â”€ openai.ts
    â””â”€â”€ analytics.ts
```

---

## ğŸš« Anti-Patterns (Never Do)

```typescript
// âŒ BAD: Using any
function transform(data: any) { ... }

// âŒ BAD: No error handling
const result = await db.collection('devices').doc(id).get();
return result.data();

// âŒ BAD: Magic numbers
if (count > 10) { ... }

// âŒ BAD: Large files
// 300+ lines of code in one file

// âŒ BAD: Trivial comments
// Get device from Firestore
const device = await getDevice(deviceId);
```

---

## âœ… Correct Patterns (Always Do)

```typescript
// âœ… GOOD: Explicit types
interface TransformRequest {
  text: string;
  deviceId: string;
  signature: string;
}

// âœ… GOOD: Proper error handling
try {
  const result = await db.collection('devices').doc(id).get();
  if (!result.exists) {
    throw new functions.https.HttpsError('not-found', 'Device not found');
  }
  return result.data() as Device;
} catch (error) {
  logger.error('Failed to get device', { deviceId: id, error });
  throw error;
}

// âœ… GOOD: Use constants
if (count > TIER_CONFIG[tier].dailyLimit) { ... }

// âœ… GOOD: Small, focused files
// Each service is 30-50 lines

// âœ… GOOD: Comments explain WHY
// Use transaction to prevent race conditions on quota
return db.runTransaction(async (transaction) => { ... });
```

---

## ğŸ”„ Workflow

**Before writing ANY code:**
1. Read `README.md` for architecture
2. Check similar services in `services/`
3. Follow existing patterns
4. Keep it small and focused

**When adding a new endpoint:**
1. Add handler in `index.ts`
2. Add validation in `validation.ts`
3. Add types in `types.ts`
4. Business logic in `services/`
5. Test with emulators

**When adding a new service:**
1. Create file in `services/`
2. Export clear interface
3. Handle errors properly
4. Keep under 100 lines
5. Add to `index.ts` if needed

---

## ğŸ§ª Testing

### Local Testing (Emulators)
```bash
firebase emulators:start
```

### Manual Testing
```bash
curl -X POST http://localhost:5001/PROJECT/us-central1/FUNCTION \
  -H "Content-Type: application/json" \
  -d '{"data": {...}}'
```

### Production Testing
- Test with small requests first
- Monitor Firebase Console logs
- Check Firestore data

---

## ğŸ”§ Firebase Specific

### Cloud Functions
- âœ… Use `https.onCall` for callable functions
- âœ… Set `timeoutSeconds` for long operations
- âœ… Use `logger` not `console.log`
- âœ… Return data in `{data: ...}` format

### Firestore
- âœ… Use **transactions** for atomic operations
- âœ… Use **batch writes** for multiple updates
- âœ… Add **TTL** for temporary data (rateLimits)
- âœ… Use **subcollections** for nested data

### Security
- âœ… Firestore rules: **server-only access**
- âœ… Validate all inputs
- âœ… Use environment config for secrets
- âœ… Never log sensitive data

---

## ğŸ“ Remember

- **Follow TypeScript best practices**
- **Keep services small** (< 100 lines)
- **Use transactions** for atomic operations
- **Validate everything** that comes from client
- **Log errors** but not sensitive data
- **Test with emulators** before deploying

---

## ğŸ”— Resources

- [Firebase Functions Docs](https://firebase.google.com/docs/functions)
- [Firestore Docs](https://firebase.google.com/docs/firestore)
- [TypeScript Best Practices](https://google.github.io/styleguide/tsguide.html)

---

**When in doubt, check the README or existing services!**
